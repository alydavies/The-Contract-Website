# Generated by Django 2.2.13 on 2021-09-05 18:40

from django.db import migrations, models
from django.db.models import Q, Count
from django.db import transaction
from django.utils import timezone
from bs4 import BeautifulSoup
from django.shortcuts import _get_queryset

GAME_STATUS = (
    # Invites go out, players may accept invites w/ characters and change whether they are coming and with which character
    # The scenario is chosen
    # GM specifies level, message, etc.
    ('SCHEDULED', 'Scheduled'),

    # The game is "activated". invites are invalidated. Players can no longer change which character is attending
    # Characters are closed for editing for the duration of the game
    # GMs have 24 hours from this point to declare the game finished, or individual players may void their attendance.
    ('ACTIVE', 'Active'),

    # Game is finished, GM declares all outcomes, characters are unlocked or declared dead. Game is officially over
    # Void proceedings may occur. Players may open game for void vote.
    # Characters are locked while a void vote is in progress.
    # Void votes may only last 24 hours
    # GM may declare void.
    ('FINISHED', 'Finished'),

    # After a set time peroid, or after any character is attending another game that is in the "ACTIVE" state, the void window
    # is closed. The game transitions into "ARCHIVED."
    ('ARCHIVED', 'Archived'),

    # Any game that is scheduled, can be canceled, which is an end state. All invites are voided. Attendances are erased.
    ('CANCELED', 'Canceled'),

    # All games that reach the "Active" state can be voided through verious means. Attendance remains on record, but is void.
    ('VOID', 'Void'),

    # Finalized games that were entered after-the-fact.
    ('RECORDED', 'Archived'),
)

WIN = 'WIN'
DEATH = 'DEATH'

def reverse_migrate_grant_scenario_rewards(apps, schema_editor):
    pass

def get_completed_game_excludes_query():
    return Q(status=GAME_STATUS[0][0]) \
           | Q(status=GAME_STATUS[1][0]) \
           | Q(status=GAME_STATUS[4][0])

def is_valid(scenario):
    return scenario.num_words > 1000


def finished_games(scenario):
    return scenario.game_set.filter(status__in=[GAME_STATUS[2][0], GAME_STATUS[3][0], GAME_STATUS[6][0]]).all()


def num_finished_games(scenario):
    return finished_games(scenario).count()


def get_steps_to_receive_improvement(scenario):
    reasons = []
    if not is_valid(scenario):
        reasons.append("Minimum 1000 words. ")
    if num_finished_games(scenario) == 0:
        reasons.append("Must be run as a Contract. ")
    return reasons

def get_object_or_none(klass, *args, **kwargs):
    queryset = _get_queryset(klass)
    try:
        return queryset.get(*args, **kwargs)
    except AttributeError:
        klass__name = klass.__name__ if isinstance(klass, type) else klass.__class__.__name__
        raise ValueError(
            "First argument to get_object_or_none() must be a Model, Manager, "
            "or QuerySet, not '%s'." % klass__name
        )
    except queryset.model.DoesNotExist:
        return None

def get_active_improvement(scenario, Reward):
    return get_object_or_none(Reward,
                              rewarded_player=scenario.creator,
                              relevant_scenario=scenario,
                              is_void=False)

def _grant_reward(scenario, Reward):
    reward = Reward(relevant_scenario=scenario,
                    rewarded_player=scenario.creator,
                    is_improvement=True,
                    awarded_on=timezone.now())
    reward.save()

def grant_or_void_reward_as_necessary(scenario, Reward):
    improvement_steps = get_steps_to_receive_improvement(scenario)
    active_improvement = get_active_improvement(scenario, Reward)
    if len(improvement_steps) == 0:
        # should have improvement
        if not active_improvement:
            _grant_reward(scenario, Reward)
    else:
        # shouldn't have improvement
        if active_improvement:
            active_improvement.mark_void()

def migrate_grant_scenario_rewards(apps, schema_editor):
    Scenario = apps.get_model('games', 'Scenario')
    Reward = apps.get_model('games', 'Reward')
    for scenario in Scenario.objects.all():
        with transaction.atomic():
            grant_or_void_reward_as_necessary(scenario, Reward)

class Migration(migrations.Migration):

    dependencies = [
        ('games', '0040_reward_relevant_scenario'),
    ]

    operations = [
        migrations.RunPython(migrate_grant_scenario_rewards, reverse_migrate_grant_scenario_rewards),
    ]
